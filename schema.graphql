### This file was generated by Nexus Schema
### Do not make changes to this file directly

"""
A bit integer.
"""
scalar BigInt

input BigIntFilter {
  equals: BigInt
  gt: BigInt
  gte: BigInt
  in: [BigInt]
  lt: BigInt
  lte: BigInt
  not: BigIntFilter
  notIn: [BigInt]
}

"""
A timestamp.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime]
  lt: DateTime
  lte: DateTime
  not: DateTimeFilter
  notIn: [DateTime]
}

"""
A number without precision limits.
"""
scalar Decimal

input DecimalFilter {
  equals: Decimal
  gt: Decimal
  gte: Decimal
  in: [Decimal]
  lt: Decimal
  lte: Decimal
  not: DecimalFilter
  notIn: [Decimal]
}

type ForwardPaginationPageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

input IdFilter {
  equals: ID
  gt: ID
  gte: ID
  in: [ID]
  lt: ID
  lte: ID
  not: IdFilter
  notIn: [ID]
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int]
  lt: Int
  lte: Int
  not: IntFilter
  notIn: [Int]
}

type Mutation {
  createSwap(
    beneficiaryAddress: String!
    destTokenId: ID!
    initiatorAddress: String!
    network: Network!
    rawRouteData: String!
    skybridgeSwapId: String
    skypoolsTransactionHash: String
    srcAmount: Decimal!
    srcTokenId: ID!
  ): Swap!
  updateSwap(id: String!, skypoolsTransactionHash: String, status: SwapStatus!): Swap!
}

enum Network {
  BSC
  ETHEREUM
  ROPSTEN
}

input NetworkEnumFilter {
  equals: Network
  in: [Network]
  not: NetworkEnumFilter
  notIn: [Network]
}

type PriceHistoricItem {
  at: DateTime!
  price: Decimal!
}

type Query {
  priceHistoric(
    """
    ID of the first token.
    """
    firstTokenId: String!

    """
    Optional ID of the second token. USD will be used if no token is provided.
    """
    secondTokenId: String
  ): [PriceHistoricItem!]!
  spender(network: Network!): String!
  swap(id: ID!): Swap!
  swapQuote(
    beneficiaryAddress: String
    destTokenAddress: String!
    initiatorAddress: String!
    network: Network!
    srcTokenAddress: String!

    """
    In human units. For example, of swapping USDT, "1" would represent 1 USDT.
    """
    srcTokenAmount: Decimal!
  ): SwapQuote!
  swaps(
    """
    Only items coming immediately after this will be returned. Can be combined with "first".
    """
    after: String

    """
    Only items coming immediately after this will be returned. Can be combined with "last".
    """
    before: String

    """
    Limits the number of items that are retuned. Can be combined with "after".
    """
    first: Int

    """
    Limits the number of items that are retuned. Can be combined with "before".
    """
    last: Int

    """
    Allows to filter results by several properties.
    """
    where: SwapWhereInput
  ): SwapsConnection!
  token(id: ID!): Token!
  tokens(
    """
    Only items coming immediately after this will be returned. Can be combined with "first".
    """
    after: String

    """
    Only items coming immediately after this will be returned. Can be combined with "last".
    """
    before: String

    """
    Limits the number of items that are retuned. Can be combined with "after".
    """
    first: Int

    """
    Limits the number of items that are retuned. Can be combined with "before".
    """
    last: Int

    """
    Allows to filter results by several properties.
    """
    where: TokenWhereInput
  ): TokensConnection!
}

input StringArrayFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  isEmpty: Boolean
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String]
  lt: String
  lte: String
  mode: StringFilterMode
  not: StringFilter
  notIn: [String]
  startsWith: String
}

enum StringFilterMode {
  default
  insensitive
}

type Swap {
  beneficiaryAddress: String!
  createdAt: DateTime!
  destAmount: Decimal!
  destToken: Token!
  id: ID!
  initiatorAddress: String!
  network: Network!
  rawRouteData: String!
  skybridgeSwapId: String
  skypoolsTransactionHashes: [String!]!
  srcAmount: Decimal!
  srcToken: Token!
  status: SwapStatus!
  updatedAt: DateTime!
}

type SwapQuote {
  bestRoute: SwapQuoteBestRoute!
  destToken: Token!
  destTokenPriceUsd: Decimal!
  nativeTokenPriceUsd: Decimal!
  otherExchanges: [SwapQuoteOtherExchange!]!
  rawRouteData: String!
  srcToken: Token!
  srcTokenAmount: Decimal!
  srcTokenAmountUsd: Decimal!
  srcTokenPriceUsd: Decimal!
}

type SwapQuoteBestRoute {
  destTokenAmount: Decimal!
  destTokenAmountUsd: Decimal!
  estimatedGas: Decimal!
  estimatedGasUsd: Decimal!
  path: [SwapQuotePathItem!]!
  spender: String!
}

type SwapQuoteOtherExchange {
  destTokenAmount: Decimal!
  destTokenAmountUsd: Decimal!
  estimatedGas: Decimal!
  estimatedGasUsd: Decimal!
  exchange: String!
  fractionOfBest: Decimal!
}

type SwapQuotePathItem {
  fraction: Decimal!
  swaps: [SwapQuotePathSwapsItem!]!
}

type SwapQuotePathSwapsExchangesItem {
  destTokenAmount: Decimal
  exchange: String!
  fraction: Decimal!
  srcTokenAmount: Decimal!
}

type SwapQuotePathSwapsItem {
  destToken: Token
  destTokenAddress: String!
  exchanges: [SwapQuotePathSwapsExchangesItem!]!
  srcToken: Token
  srcTokenAddress: String!
}

enum SwapStatus {
  COMPLETED
  FAILED
  PENDING
}

input SwapWhereInput {
  AND: [SwapWhereInput]
  NOT: SwapWhereInput
  OR: [SwapWhereInput]
  beneficiaryAddress: StringFilter
  createdAt: DateTimeFilter
  destAmount: DecimalFilter
  destToken: TokenWhereInput
  id: IdFilter
  initiatorAddress: StringFilter
  network: NetworkEnumFilter
  skybridgeSwapId: StringFilter
  skypoolsTransactionHashes: StringArrayFilter
  srcAmount: DecimalFilter
  srcToken: TokenWhereInput
  updatedAt: DateTimeFilter
}

type SwapsConnection {
  edges: [SwapsConnectionEdges!]!
  pageInfo: ForwardPaginationPageInfo!
  totalCount: Int!
}

type SwapsConnectionEdges {
  cursor: String!
  node: Swap!
}

type Token {
  address: String!
  createdAt: DateTime!
  decimals: Int!
  id: String!
  logoUri: String
  network: Network!
  symbol: String!
  updatedAt: DateTime!
}

input TokenWhereInput {
  AND: [TokenWhereInput]
  NOT: TokenWhereInput
  OR: [TokenWhereInput]
  address: StringFilter
  createdAt: DateTimeFilter
  decimals: IntFilter
  id: StringFilter
  logoUri: StringFilter
  network: NetworkEnumFilter
  symbol: StringFilter
  updatedAt: DateTimeFilter
}

type TokensConnection {
  edges: [TokensConnectionEdges!]!
  pageInfo: ForwardPaginationPageInfo!
  totalCount: Int!
}

type TokensConnectionEdges {
  cursor: String!
  node: Token!
}
